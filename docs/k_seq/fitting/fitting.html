<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.4" />
<title>k_seq.fitting.fitting API documentation</title>
<meta name="description" content="Methods needed for fitting" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>k_seq.fitting.fitting</code> module</h1>
</header>
<section id="section-intro">
<p>Methods needed for fitting</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Methods needed for fitting
&#34;&#34;&#34;

from scipy.optimize import curve_fit
import numpy as np
import pandas as pd
import multiprocessing as mp


def func_default(x, A, k):
    &#34;&#34;&#34;
    Default kinetic model used in BYO k-seq fitting:
                    A * (1 - np.exp(- 0.479 * 90 * k * x))
    90: t, reaction time (min)
    0.479: alpha, degradation adjustment parameter for BYO in 90 min

    :param x: predictor for the regression model, here is initial concentration of BYO
    :param A: parameter represents the maximal conversion of reactants
    :param k: parameter represents the apparent kinetic coefficient
    :return: reacted fraction given the independent variable x and parameter (A, k)
    &#34;&#34;&#34;
    return A * (1 - np.exp(- 0.479 * 90 * k * x))  # BYO degradation adjustment and 90 minutes


def get_args_num(func, exclude_x=True):
    &#34;&#34;&#34;
    Utility function to get the number of arguments for a callable
    :param func: callable, the function
    :param exclude_x: boolean, return the number of arguments minus 1 if true
    :return: number of arguments of the function func
    &#34;&#34;&#34;
    from inspect import signature
    sig = signature(func)
    if exclude_x:
        param_num = len(sig.parameters) - 1
    else:
        param_num = len(sig.parameters)
    return param_num


def fitting_single(x_data, y_data, func=func_default, weights=None, bounds=None,
                   bootstrap=True, bs_depth=1000, bs_return_verbose=True, bs_residue=False,
                   missing_data_as_zero=False, y_max=None, **kwargs):

    &#34;&#34;&#34;
    Core method for fitting. Fit on a single sequence
    :param x_data: list-like. A list of x values of data points to fit
    :param y_data: list-like, same size as x_data. y values of data points to fit, should keep same order as x_data.
                   np.nan is allowed
    :param func: callable. Model function for fitting.
    :param weights: optional. Weights of each data points in fitting, same size as x_data
    :param bounds: a tuple of two tuples.
                   ((lower_bound_0, lower_bound_1, ..., lower_bound_k),
                    (upper_bound_0, upper_bound_1, ..., upper_bound_k))
    :param bootstrap: boolean. If true, use bootstrap to estimate the confidence interval of parameters
    :param bs_depth: int. Number of bootstrap samples to use to estimate the confidence interval
    :param bs_return_verbose: boolean. If true, return the list of parameters for each bootstrap sample
    :param bs_residue: boolean. If true, resample precent residue instead of data points in bootstrap
    :param missing_data_as_zero: boolean. If true, the missing data (np.nan) will be treated as zero
    :param y_max: optional. float if not None. The maximum y value can be accepted
    :param kwargs: no other key arguments, only for completeness
    :return: results: a dictionary of fitting results,
             param_list: a list of parameters from each bootstrap samples. None if bs_return_verbose = False
    &#34;&#34;&#34;
    param_num = get_args_num(func)
    # regularize data format
    x_data = np.array(list(x_data))
    y_data = np.array(list(y_data))
    if y_max is not None:
        y_data = np.array([min(yi, y_max) for yi in y_data])
    if missing_data_as_zero:
        y_data[np.isnan(y_data)] = 0
    if bounds is None:
        bounds = [[-np.inf for _ in range(param_num)], [np.inf for _ in range(param_num)]]
    if not weights:
        weights = np.ones(len(y_data))
    # only include non np.nan data
    valid = ~np.isnan(y_data)
    x_data = x_data[valid]
    y_data = y_data[valid]
    weights = weights[valid]
    results = {
        &#39;x_data&#39;: x_data,
        &#39;y_data&#39;: y_data,
        &#39;fitting_weights&#39;: weights
    }
    try:
        init_guess = [np.random.random() for _ in range(param_num)]
        results[&#39;params&#39;], results[&#39;pcov&#39;] = curve_fit(func, xdata=x_data, ydata=y_data, sigma=weights,
                                                       method=&#39;trf&#39;, bounds=bounds, p0=init_guess)
        y_hat = func(x_data, *results[&#39;params&#39;])
        res = y_data - y_hat
        results[&#39;pct_res&#39;] = res / y_hat
    except RuntimeError:
        results[&#39;params&#39;] = [np.nan for _ in range(param_num)]

    if bootstrap:
        param_list = []
        if (len(x_data) &gt; 1)and(~np.isnan(results[&#39;params&#39;][0])):
            for _ in range(bs_depth):
                if bs_residue:
                    pct_res_resampled = np.random.choice(results[&#39;pct_res&#39;], replace=True, size=len(results[&#39;pct_res&#39;]))
                    y_data_bs = y_hat * (1 + pct_res_resampled)
                    x_data_bs = x_data
                else:
                    indices = np.linspace(0, len(x_data) - 1, len(x_data))
                    bs_indeces = np.random.choice(a=indices, size=len(x_data), replace=True)
                    x_data_bs = np.array([x_data[int(i)] for i in bs_indeces])
                    y_data_bs = np.array([y_data[int(i)] for i in bs_indeces])
                try:
                    init_guess = [np.random.random() for _ in range(param_num)]
                    params, pcov = curve_fit(func, xdata=x_data_bs, ydata=y_data_bs,
                                             method=&#39;trf&#39;, bounds=bounds, p0=init_guess)
                except:
                    params = [np.nan for _ in range(param_num)]
                param_list.append(params)

            results[&#39;mean&#39;] = np.nanmean(param_list, axis=0)
            results[&#39;sd&#39;] = np.nanstd(param_list, axis=0, ddof=1)
            results[&#39;p2.5&#39;] = np.percentile(param_list, 2.5, axis=0)
            results[&#39;p50&#39;] = np.percentile(param_list, 50, axis=0)
            results[&#39;p97.5&#39;] = np.percentile(param_list, 97.5, axis=0)
        else:
            results[&#39;sd&#39;] = np.nan
    if bs_return_verbose:
        return results, param_list
    else:
        return results, None


def fitting_master(seq, **kwargs):
    &#34;&#34;&#34;
    Master fitting function to convert a iteration from pd.DataFrame.iterrows() to input type for fitting_single
    :param seq: one item from pd.DataFrame.iterrows()
    :param kwargs: all other keyword arguments need to pass to fitting_single()
    :return: return pd.Series object containing the fitting results
    &#34;&#34;&#34;

    single_res = fitting_single(y_data=list(seq[1]), **kwargs)
    return pd.Series(single_res[0], name=seq[0]), (seq[0], single_res[1])


def fitting_sequence_set(sequence_set, bs_return_verbose=True, parallel_threads=None, inplace=True, **kwargs):
    &#34;&#34;&#34;
    Method to apply fitting on all sequences in sequence_set
    :param sequence_set:
    :param bs_return_verbose:
    :param parallel_threads:
    :param inplace:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    from functools import partial

    partial_func = partial(fitting_master,
                           x_data=sequence_set.reacted_frac_table.col_x_values,
                           bs_return_verbose=bs_return_verbose,
                           **kwargs)

    if parallel_threads:
        pool = mp.Pool(processes=int(parallel_threads))
        results = pool.map(partial_func, sequence_set.reacted_frac_table.iterrows())
    else:
        results = [partial_fun(seq) for seq in sequence_set.reacted_frac_table.iterrows()]

    if inplace:
        sequence_set.fitting_results = pd.DataFrame([res[0] for res in results])
        if bs_return_verbose:
            sequence_set.bs_log = {res[1][0]:res[1][1] for res in results}
    else:
        if bs_return_verbose:
            return pd.DataFrame([res[0] for res in results]), {res[1][0]:res[1][1] for res in results}
        else:
            return pd.DataFrame([res[0] for res in results])


# TODO: make a full script to run the whole</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="k_seq.fitting.fitting.fitting_master"><code class="name flex">
<span>def <span class="ident">fitting_master</span></span>(<span>seq, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Master fitting function to convert a iteration from pd.DataFrame.iterrows() to input type for fitting_single
:param seq: one item from pd.DataFrame.iterrows()
:param kwargs: all other keyword arguments need to pass to fitting_single()
:return: return pd.Series object containing the fitting results</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fitting_master(seq, **kwargs):
    &#34;&#34;&#34;
    Master fitting function to convert a iteration from pd.DataFrame.iterrows() to input type for fitting_single
    :param seq: one item from pd.DataFrame.iterrows()
    :param kwargs: all other keyword arguments need to pass to fitting_single()
    :return: return pd.Series object containing the fitting results
    &#34;&#34;&#34;

    single_res = fitting_single(y_data=list(seq[1]), **kwargs)
    return pd.Series(single_res[0], name=seq[0]), (seq[0], single_res[1])</code></pre>
</details>
</dd>
<dt id="k_seq.fitting.fitting.fitting_sequence_set"><code class="name flex">
<span>def <span class="ident">fitting_sequence_set</span></span>(<span>sequence_set, bs_return_verbose=True, parallel_threads=None, inplace=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to apply fitting on all sequences in sequence_set
:param sequence_set:
:param bs_return_verbose:
:param parallel_threads:
:param inplace:
:param kwargs:
:return:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fitting_sequence_set(sequence_set, bs_return_verbose=True, parallel_threads=None, inplace=True, **kwargs):
    &#34;&#34;&#34;
    Method to apply fitting on all sequences in sequence_set
    :param sequence_set:
    :param bs_return_verbose:
    :param parallel_threads:
    :param inplace:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    from functools import partial

    partial_func = partial(fitting_master,
                           x_data=sequence_set.reacted_frac_table.col_x_values,
                           bs_return_verbose=bs_return_verbose,
                           **kwargs)

    if parallel_threads:
        pool = mp.Pool(processes=int(parallel_threads))
        results = pool.map(partial_func, sequence_set.reacted_frac_table.iterrows())
    else:
        results = [partial_fun(seq) for seq in sequence_set.reacted_frac_table.iterrows()]

    if inplace:
        sequence_set.fitting_results = pd.DataFrame([res[0] for res in results])
        if bs_return_verbose:
            sequence_set.bs_log = {res[1][0]:res[1][1] for res in results}
    else:
        if bs_return_verbose:
            return pd.DataFrame([res[0] for res in results]), {res[1][0]:res[1][1] for res in results}
        else:
            return pd.DataFrame([res[0] for res in results])</code></pre>
</details>
</dd>
<dt id="k_seq.fitting.fitting.fitting_single"><code class="name flex">
<span>def <span class="ident">fitting_single</span></span>(<span>x_data, y_data, func=&lt;function func_default at 0x7fb0b8b5d1e0&gt;, weights=None, bounds=None, bootstrap=True, bs_depth=1000, bs_return_verbose=True, bs_residue=False, missing_data_as_zero=False, y_max=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Core method for fitting. Fit on a single sequence
:param x_data: list-like. A list of x values of data points to fit
:param y_data: list-like, same size as x_data. y values of data points to fit, should keep same order as x_data.
np.nan is allowed
:param func: callable. Model function for fitting.
:param weights: optional. Weights of each data points in fitting, same size as x_data
:param bounds: a tuple of two tuples.
((lower_bound_0, lower_bound_1, &hellip;, lower_bound_k),
(upper_bound_0, upper_bound_1, &hellip;, upper_bound_k))
:param bootstrap: boolean. If true, use bootstrap to estimate the confidence interval of parameters
:param bs_depth: int. Number of bootstrap samples to use to estimate the confidence interval
:param bs_return_verbose: boolean. If true, return the list of parameters for each bootstrap sample
:param bs_residue: boolean. If true, resample precent residue instead of data points in bootstrap
:param missing_data_as_zero: boolean. If true, the missing data (np.nan) will be treated as zero
:param y_max: optional. float if not None. The maximum y value can be accepted
:param kwargs: no other key arguments, only for completeness
:return: results: a dictionary of fitting results,
param_list: a list of parameters from each bootstrap samples. None if bs_return_verbose = False</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fitting_single(x_data, y_data, func=func_default, weights=None, bounds=None,
                   bootstrap=True, bs_depth=1000, bs_return_verbose=True, bs_residue=False,
                   missing_data_as_zero=False, y_max=None, **kwargs):

    &#34;&#34;&#34;
    Core method for fitting. Fit on a single sequence
    :param x_data: list-like. A list of x values of data points to fit
    :param y_data: list-like, same size as x_data. y values of data points to fit, should keep same order as x_data.
                   np.nan is allowed
    :param func: callable. Model function for fitting.
    :param weights: optional. Weights of each data points in fitting, same size as x_data
    :param bounds: a tuple of two tuples.
                   ((lower_bound_0, lower_bound_1, ..., lower_bound_k),
                    (upper_bound_0, upper_bound_1, ..., upper_bound_k))
    :param bootstrap: boolean. If true, use bootstrap to estimate the confidence interval of parameters
    :param bs_depth: int. Number of bootstrap samples to use to estimate the confidence interval
    :param bs_return_verbose: boolean. If true, return the list of parameters for each bootstrap sample
    :param bs_residue: boolean. If true, resample precent residue instead of data points in bootstrap
    :param missing_data_as_zero: boolean. If true, the missing data (np.nan) will be treated as zero
    :param y_max: optional. float if not None. The maximum y value can be accepted
    :param kwargs: no other key arguments, only for completeness
    :return: results: a dictionary of fitting results,
             param_list: a list of parameters from each bootstrap samples. None if bs_return_verbose = False
    &#34;&#34;&#34;
    param_num = get_args_num(func)
    # regularize data format
    x_data = np.array(list(x_data))
    y_data = np.array(list(y_data))
    if y_max is not None:
        y_data = np.array([min(yi, y_max) for yi in y_data])
    if missing_data_as_zero:
        y_data[np.isnan(y_data)] = 0
    if bounds is None:
        bounds = [[-np.inf for _ in range(param_num)], [np.inf for _ in range(param_num)]]
    if not weights:
        weights = np.ones(len(y_data))
    # only include non np.nan data
    valid = ~np.isnan(y_data)
    x_data = x_data[valid]
    y_data = y_data[valid]
    weights = weights[valid]
    results = {
        &#39;x_data&#39;: x_data,
        &#39;y_data&#39;: y_data,
        &#39;fitting_weights&#39;: weights
    }
    try:
        init_guess = [np.random.random() for _ in range(param_num)]
        results[&#39;params&#39;], results[&#39;pcov&#39;] = curve_fit(func, xdata=x_data, ydata=y_data, sigma=weights,
                                                       method=&#39;trf&#39;, bounds=bounds, p0=init_guess)
        y_hat = func(x_data, *results[&#39;params&#39;])
        res = y_data - y_hat
        results[&#39;pct_res&#39;] = res / y_hat
    except RuntimeError:
        results[&#39;params&#39;] = [np.nan for _ in range(param_num)]

    if bootstrap:
        param_list = []
        if (len(x_data) &gt; 1)and(~np.isnan(results[&#39;params&#39;][0])):
            for _ in range(bs_depth):
                if bs_residue:
                    pct_res_resampled = np.random.choice(results[&#39;pct_res&#39;], replace=True, size=len(results[&#39;pct_res&#39;]))
                    y_data_bs = y_hat * (1 + pct_res_resampled)
                    x_data_bs = x_data
                else:
                    indices = np.linspace(0, len(x_data) - 1, len(x_data))
                    bs_indeces = np.random.choice(a=indices, size=len(x_data), replace=True)
                    x_data_bs = np.array([x_data[int(i)] for i in bs_indeces])
                    y_data_bs = np.array([y_data[int(i)] for i in bs_indeces])
                try:
                    init_guess = [np.random.random() for _ in range(param_num)]
                    params, pcov = curve_fit(func, xdata=x_data_bs, ydata=y_data_bs,
                                             method=&#39;trf&#39;, bounds=bounds, p0=init_guess)
                except:
                    params = [np.nan for _ in range(param_num)]
                param_list.append(params)

            results[&#39;mean&#39;] = np.nanmean(param_list, axis=0)
            results[&#39;sd&#39;] = np.nanstd(param_list, axis=0, ddof=1)
            results[&#39;p2.5&#39;] = np.percentile(param_list, 2.5, axis=0)
            results[&#39;p50&#39;] = np.percentile(param_list, 50, axis=0)
            results[&#39;p97.5&#39;] = np.percentile(param_list, 97.5, axis=0)
        else:
            results[&#39;sd&#39;] = np.nan
    if bs_return_verbose:
        return results, param_list
    else:
        return results, None</code></pre>
</details>
</dd>
<dt id="k_seq.fitting.fitting.func_default"><code class="name flex">
<span>def <span class="ident">func_default</span></span>(<span>x, A, k)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt>Default kinetic model used in BYO k-seq fitting:</dt>
<dt>A * (1 - np.exp(- 0.479 * 90 * k * x))</dt>
<dt><strong><code>90</code></strong> :&ensp;<code>t</code>, <code>reaction</code> <code>time</code> (<code>min</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<p>0.479: alpha, degradation adjustment parameter for BYO in 90 min</p>
<p>:param x: predictor for the regression model, here is initial concentration of BYO
:param A: parameter represents the maximal conversion of reactants
:param k: parameter represents the apparent kinetic coefficient
:return: reacted fraction given the independent variable x and parameter (A, k)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def func_default(x, A, k):
    &#34;&#34;&#34;
    Default kinetic model used in BYO k-seq fitting:
                    A * (1 - np.exp(- 0.479 * 90 * k * x))
    90: t, reaction time (min)
    0.479: alpha, degradation adjustment parameter for BYO in 90 min

    :param x: predictor for the regression model, here is initial concentration of BYO
    :param A: parameter represents the maximal conversion of reactants
    :param k: parameter represents the apparent kinetic coefficient
    :return: reacted fraction given the independent variable x and parameter (A, k)
    &#34;&#34;&#34;
    return A * (1 - np.exp(- 0.479 * 90 * k * x))  # BYO degradation adjustment and 90 minutes</code></pre>
</details>
</dd>
<dt id="k_seq.fitting.fitting.get_args_num"><code class="name flex">
<span>def <span class="ident">get_args_num</span></span>(<span>func, exclude_x=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Utility function to get the number of arguments for a callable
:param func: callable, the function
:param exclude_x: boolean, return the number of arguments minus 1 if true
:return: number of arguments of the function func</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_args_num(func, exclude_x=True):
    &#34;&#34;&#34;
    Utility function to get the number of arguments for a callable
    :param func: callable, the function
    :param exclude_x: boolean, return the number of arguments minus 1 if true
    :return: number of arguments of the function func
    &#34;&#34;&#34;
    from inspect import signature
    sig = signature(func)
    if exclude_x:
        param_num = len(sig.parameters) - 1
    else:
        param_num = len(sig.parameters)
    return param_num</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="k_seq.fitting" href="index.html">k_seq.fitting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="k_seq.fitting.fitting.fitting_master" href="#k_seq.fitting.fitting.fitting_master">fitting_master</a></code></li>
<li><code><a title="k_seq.fitting.fitting.fitting_sequence_set" href="#k_seq.fitting.fitting.fitting_sequence_set">fitting_sequence_set</a></code></li>
<li><code><a title="k_seq.fitting.fitting.fitting_single" href="#k_seq.fitting.fitting.fitting_single">fitting_single</a></code></li>
<li><code><a title="k_seq.fitting.fitting.func_default" href="#k_seq.fitting.fitting.func_default">func_default</a></code></li>
<li><code><a title="k_seq.fitting.fitting.get_args_num" href="#k_seq.fitting.fitting.get_args_num">get_args_num</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>